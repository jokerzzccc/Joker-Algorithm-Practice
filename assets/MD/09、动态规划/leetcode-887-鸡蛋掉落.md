# 目录

[toc]

# leetcode-887-鸡蛋掉落

- 时间：2023-06-23
- 参考链接：
  - [经典动态规划：高楼扔鸡蛋](https://labuladong.gitee.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/jing-dian--06fca/)
  - [高楼扔鸡蛋问题完全解析](https://mp.weixin.qq.com/s/5Ssp0Cwd6wr8vPKR0lHtTQ)
    - 付费，用微信打开
  - 




# 1、题目

- 题目：https://leetcode.cn/problems/super-egg-drop/
- 难度：困难



给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。

已知存在楼层 f ，满足 0 <= f <= n ，任何从 **高于** f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 **重复使用** 这枚鸡蛋。

请你计算并返回要确定 f **确切的值** 的 **最小操作次数** 是多少？



**提示：**

+ `1 <= k <= 100`
+ `1 <= n <= 10^4`





# 2、题解

## 题目分析

1、N 和 F 的关系

N 的定义：使用一栋从 1 到 N 共有 N 层楼的建筑
F 的定义：满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破
因此得知，F 比 N 多一个 0 层

2、问题转换

将问题从： N 个楼层，有 K 个蛋，求最少要扔 T 次，才能保证当 F 无论是 0 <= F <= N 中哪个值，都能测试出来
转变为：有 K 个蛋，扔 T 次，求可以确定 F 的个数，然后得出 N 个楼层



你面前有一栋从1到N共N层的楼，然后给你K个鸡蛋(K至少为1)。现在确定这栋楼存在楼层`0<=F<=N`，在这层楼将鸡蛋扔下去，鸡蛋**怡好没摔碎**(高于 F 的楼层都会碎，低于 F 的楼层都不会碎)。现在问你，**最坏情况**下，你**至少**要扔几次鸡蛋，才能**确定**这个楼层F呢？

也就是让你找摔不碎鸡蛋的最高楼层F,但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。

比方说现在**先不管鸡蛋个数的限制**，有7层楼，你怎么去找鸡蛋恰好摔碎的那层楼？
最原始的方式就是线性扫描：我先在1楼扔一下，没碎，我再去2楼扔一下，没碎，我再去3楼..…
以这种策略，**最坏**情况应该就是我试到第7层鸡蛋也没碎（至=7），也就是我扔了7次鸡蛋。

先在你应该理解什么叫做「**最坏情况**」下了，**鸡蛋破碎一定发生在搜索区间穷尽时**，不会说你在第1层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。
现在再来理解一下什么叫「**至少**」要扔几次。依然不考虑鸡蛋个数限制，同样是7层楼，我们可以优化策略。
最好的策略是使用二分查找思路，我先去第`(1+7)/2=4`层扔一下：

- 如果碎了说明 F 小于4，我就去第`(1+3)/2=2`层试...
- 如果没碎说明 F 大于等于4，我就去第`(5+7)/2=6`层试.

以这种策略，**最坏**情况应该是试到第7层鸡蛋还没碎(F=7),或者鸡蛋一直碎到第1层(F=0)。然而无论那种最坏情况，只需要试1og7向上取整等于3次，比刚才尝试7次要少，这就是所谓的**至少**要扔几次。



实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，**现在给你了鸡蛋个数的限制K,直接使用二分思路就不行了**。
比如说只给你1个鸡蛋，7层楼，你敢用二分吗？你直接去第4层扔一下，如果鸡蛋没碎还好，但如果碎了你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层了。这种情况下只能用线性扫描的方法，算法返回结果应该是7。

有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩1个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？
很遗憾，并不是，比如说把楼层变高一些，100层，给你2个鸡蛋，你在50层扔一下，碎了，那就只能线性扫描1~49层了，最坏情况下要扔50次。
如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过20次。

最优解其实是14次。最优策略非常多，而且并没有什么规律可言。

说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？

## 解法一: 动态规划+二分查找

### 算法分析

对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。

- **「状态」很明显，就是当前拥有的鸡蛋数K和需要测试的楼层数N。**随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。
- **「选择」其实就是去选择哪层楼扔鸡蛋。**回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。



现在明确了「状态」和「选择」，**动态规划的基本思路**就形成了：肯定是个二维的dp数组或者带有两个状态参数的dp函数来表示状态转移；外加一个for循环来遍历所有选择，择最优的选择更新状态：

```python
#当前状态为K个鸡蛋，面对N层楼
#返回这个状态下的最优结果
int dp(int K,int N):
    int res
    for 1<=i<=N:
    	res=min(res,这次在第i层楼扔鸡蛋)
    return res
```

这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。
我们选择在第`i`层楼扔了鸡蛋之后，**可能出现两种情况：鸡蛋碎了，鸡蛋没碎**。注意，这时候状态转移就来了：

- 如果**鸡蛋碎了**，那么鸡蛋的个数`K`应该减一，搜索的楼层区间应该从`[1..N]`变为 `[1..i-1]` 共 `i-1` 层楼；
- 如果鸡蛋没碎，那么鸡蛋的个数`K`不变，搜索的楼层区间应该从`[1..N]`变为`[i+1..N]`共`N-i`层楼。

![image-20230623140420686](https://2021-joker.oss-cn-shanghai.aliyuncs.com/java_img/image-20230623140420686.png)

>PS：细心的读者可能会问，在第层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第层楼呀？不必，因为已经包含了。开头说了F是可以等于0的，向上递归后，第层楼其实就相当于第0层，可以被取到，所以说并没有错误。

因为我们要求的是**最坏情况下**扔鸡蛋的次数，所以鸡蛋在第1层楼碎没碎，取决于哪种情况的结果**更大**：
```java
int dp(int K,int N):
	for 1<= i <=N:
		#最坏情况下的最少扔鸡蛋次数
        res = min(res,
        		max(
                    dp(K-1,i-1),#碎
                    dp(K,N-i)  #没碎
        			)+1 #在第1楼扔了一次
	return res
```

递归的base case很容易理解：当楼层数`N`等于0时，显然不需要扔鸡蛋；当鸡蛋数`K`为1时，显然只能线性扫描所有楼层：

```java
def dp(K,N)
	if K =1:return N
	if N =0:return 0
```

至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：

```python
def superEggDrop(K:int,N:int):
    memo dict()
    def dp(K,N)->int:
        # base case
        if K =1:return N
        if N =0:return 0
        #避免重复计算
        if (K,N)in memo:
        	return memo[(K,N)]
        
        res float('INF')
        #穷举所有可能的选择
        for i in range(1,N+1):
            res min(res,
                    max(
                        dp(K,N-i),
                        dp(K-1,i-1)
                    )+1
        #记入备忘录
        memo[(K,N)]=res
        return res
    return dp(K,N)
```

这个算法的时间复杂度是多少呢？**动态规划算法的时间复杂度就是子问题个数×函数本身的复杂度**。

- 函数本身的复杂度就是忽略递归部分的复杂度，这里`dp`函数中有一个`for`循环，所以函数本身的复杂度是O(N)。
- 子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是`O(KN)`。所以算法的总时间复杂度是O(K*N^2),空间复杂度O(KN)。

这个问题很复杂，但是算法代码却十分简洁，这就是动态规划的特性，穷举加备忘录/DP table优化，真的没啥新意。



有读者可能不理解代码中为什么用一个 for 循环遍历楼层`[1..N]`，也许会把这个逻辑和之前探讨的线性扫描混为一谈。其实不是的，**这只是在做一次「选择」**。

- 比方说你有2个鸡蛋，面对10层楼，你**这次**选择去哪一层楼扔呢？不知道，那就把这10层楼全试一遍。至于下次怎么选择不用你操心，有正确的状态转移，递归算法会把每个选择的代价都算出来，我们取最优的那个就是最优解。



另外，这个问题还有**更好**的解法，比如修改代码中的 for 循环为**二分搜索**，可以将时间复杂度降为`O(K*N*logN)`;再改进动态规划解法可以进一步降为`O(KN)`;使用**数学方法**解决，时间复杂度达到最优O(K*1ogN),空间复杂度达到O(1)。
二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔鸡蛋有关系，实际上没有半毛钱关系。能用二分搜索是因为状态转移方程的函数图像具有单调性，可以快速找到最值。

接下来我们看一看如何优化。



#### 二分搜索优化

二分搜索的优化的核心是状态转移方程的单调性，首先简述一下原始动态规划的思路：
1、暴力穷举尝试在所有楼层`1<=i<=N`扔鸡蛋，每次选择尝试次数最少的那一层；
2、每次扔鸡蛋有两种可能，要么碎，要么没碎：
3、如果鸡蛋碎了，`F`应该在第 `i` 层下面，否则，`F` 应该在第 `i` 层上面；
4、鸡蛋是碎了还是没碎，取决于哪种情况下尝试次数**更多**，因为我们想求的是最坏情况下的结果。

核心的状态转移代码是这段：

```python
#当前状态为K个鸡蛋，面对N层楼
#返回这个状态下的最优结果
def dp(K,N):
    for 1<=i<=N:
        #最坏情况下的最少扔鸭蛋次数
        res min(res,
                max(
                    dp(K-1,i-1),#碎
                    dp(K,N -i) #没碎
                ) + 1 # 在第1楼扔了一次
    return res
```

这个 for 循环就是下面这个状态转移方程的具体代码实现：

![image-20230623142904564](https://2021-joker.oss-cn-shanghai.aliyuncs.com/java_img/image-20230623142904564.png)

如果能够理解这个状态转移方程，那么就很容易理解二分查找的优化思路。
首先我们根据`dp(K,N)`数组的定义（有K个鸡蛋面对`N`层楼，最少需要扔几次)，**很容易知道 `K` 固定时，这个函数随着`N`的增加一定是单调递增的**，无论你策略多聪明，楼层增加测试次数一定要增加。
那么注意`dp(K-1,i-1)`和`dp(K,N-i)`这两个函数，其中i是从`i`到`N`单增的，如果我们固定`K`和`N`,**把这两个函数看做关于`i`的函数，前者随着`i`的增加应该也是单调递增的，而后者随着`i`的增加应该是单调递减的**：

![image-20230623143143115](https://2021-joker.oss-cn-shanghai.aliyuncs.com/java_img/image-20230623143143115.png)

这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。
我们前文二分查找的运用技巧讲过，二分查找的运用很广泛，形如下面这种形式的
for循环代码：

```java
for (int i=0;i<n;i++){
    if (f(i))
    	return i;
```

都很有可能可以运用二分查找来优化线性搜索的复杂度，回顾这两个dp函数的曲线，我们要找的最低点其实就是这种情况：
```java
for (int i=1;i <N;i++){
    if (dp(K-1,i-1)==dp(K,N-i))
    	return dp(K,N-i);
```

熟悉二分搜索的同学肯定敏感地想到了，这不就是相当于求 Valley (山谷)值嘛，可以用二分查找来快速寻找这个点的，直接看代码吧，整体的思路还是一样，只是加快了搜索速度：

```python
class Solution:
    def superEggDrop(self, K: int, N: int) -> int:
        memo = {}
        def dp(K,N):
            if K == 1:return N
            if N == 0:return 0
            if (K,N) in memo:
                return memo[K,N]

            # for 1<=i<=N:
            #    res = min(res,
            #            max(
            #                dp(K-1,i-1)
            #                dp(K,N-i)
            #               )+1

            res = float('INF')
            #用二分搜索代替线性搜索
            lo,hi 1,N
            while lo <= hi:
                mid =(1o + hi) // 2
                broken = dp(K -1,mid-1)  # 碎
                not_broken = dp(K,N-mid) # 没碎
                #res=min(max(碎，没碎)+1)
                if broken > not_broken:
                    hi=mid-1
                    res=min(res,broken+1)
                else:
                    lo=mid+1
                    res min(res,not_broken +1)
            memo[K,N] = res
            return memo[K,N]

        return dp(K,N)
```

这个算法的时间复杂度是多少呢？**动态规划算法的时间复杂度就是子问题个数×函数本身的复杂度**。

- 函数本身的复杂度就是忽略递归部分的复杂度，这里`dp`函数中用了一个二分搜索，所以函数本身的复杂度是O(IogN)。
- 子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是O(KN)。

所以算法的总时间复杂度是`O(KNlogN)`,空间复杂度`O(KN)`。效率上比之前的算法O(KN^2)要高效一些。



### 代码

```java


/**
 * <p>
 * 鸡蛋掉落
 * </p>
 *
 * @author admin
 * @date 2023/6/23
 */
public class leetcode887 {

    public static void main(String[] args) {
        int k = 1;
        int n = 2;

        Solution01 solution01 = new Solution01();
        System.out.println(solution01.superEggDrop(k, n));

    }

    /**
     * 解法一：动态规划 + 二分搜索
     */
    private static class Solution01 {

        //下面写一下使用二分搜索优化的自顶向下的动态规划算法。
        //使用动态规划必须先明确状态和选择 状态：可以尝试的鸡蛋次数，楼层数  选择：从哪个楼层扔鸡蛋
        //因为是一个自顶向下的动态规划问题，这个问题中有重叠子问题，所以使用备忘录来消除重叠子问题
        int[][] memo;

        public int superEggDrop(int k, int n) {
            //整体右移一位，从下标1开始更符合生活实际
            memo = new int[k + 1][n + 1];
            for (int[] ints : memo) {
                Arrays.fill(ints, -1);
            }
            return dp(k, n);
        }

        //声明一下dp函数的定义：当有k个鸡蛋，n层楼的时候确定恰好不碎的楼层的最少尝试次数为dp(k,n)
        private int dp(int k, int n) {
            //base case
            //1.当我们只有一个鸡蛋的时候，只能进行线性扫描才能确定最坏情况下的恰好不碎的楼层
            if (k == 1) {
                return n;
            }
            //2.当楼层为0或者鸡蛋为0的时候，尝试的次数肯定为0
            if (k == 0 || n == 0) {
                return 0;
            }
            if (memo[k][n] != -1) {
                return memo[k][n];
            }
            //状态转移方程：如果此时碎了，那么楼层在当前楼层的下面，楼层数为i-1 如果没有随楼层在当前楼层上面，楼层数为n-i
            // 因为是最坏情况下所以碎没碎取决于尝试的次数，选择尝试次数多的那个
            int res = Integer.MAX_VALUE;
            int low = 1, high = n;
            while (low <= high) {
                //这个mid其实就是使用二分搜索快速知道的中间的尝试楼层，也就是当前扔的那个楼层
                int mid = (low + high) / 2;
                //鸡蛋碎的情况
                int broken = dp(k - 1, mid - 1);
                //鸡蛋没有碎的情况
                int not_broken = dp(k, n - mid);
                //因为是最坏情况下，所以我们选择碎或者没碎中尝试次数最多，也就是最大的那个
                if (broken > not_broken) {
                    //碎的情况下尝试的次数多于不碎
                    //下次我们应该去楼下尝试
                    high = mid - 1;
                    //因为最后结果是尝试次数最少，所以取最小值
                    res = Math.min(res, broken + 1);
                } else {
                    //不碎的情况下尝试的次数多于碎
                    //下次我们应该去楼上尝试
                    low = mid + 1;
                    res = Math.min(res, not_broken + 1);
                }
            }
            memo[k][n] = res;
            return res;
        }

    }

}

```





### 复杂度分析

- 时间复杂度：$O(kn*logn)$
- 空间复杂度：$O(kn)$







# THE END