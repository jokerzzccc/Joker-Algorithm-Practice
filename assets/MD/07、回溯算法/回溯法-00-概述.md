# 目录

[toc]

# 回溯法-00-概述

- 时间：2023-04-29
- 参考链接：
  - [回溯算法解题套路框架-labuladong](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/)
  - [回溯算法理论基础-代码随想录](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)
  - 




# 回溯类题目分类大纲

![image-20230508223333039](https://2021-joker.oss-cn-shanghai.aliyuncs.com/java_img/image-20230508223333039.png)





# 什么是回溯法

- 回溯法也可以叫做回溯搜索法，它是一种搜索的方式。
- **回溯是递归的副产品，只要有递归就会有回溯。**
- **所以以下讲解中，回溯函数也就是递归函数，指的都是一个函数**。
- 回溯法可以看成蛮力法的升级版，它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。
- 回溯法非常适合**由多个步骤组成的问题，并且每个步骤都有多个选项**。当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。我们就这样重复选择，直到达最终的状态。
- 用回溯法解决的问题的所有选项可以形象地用**树状结构**表示。在某一步有n个可能的选项，那么该步骤可以看成是树状结构中的一个节点，每个选项看成树中节点连接线，经过这些连接线到达该节点的n个子节点。树的**叶节点**对应着**终结状态**。如果在叶节点的状态满足题目的约束条件，那么我们找到了一个**可行的解决方案**。
- 如果在叶节点的状态不满足约束条件，那么只好回溯到它的上一个节点再尝试其他的选项。如果上一个节点所有可能的选项都已经试过，并且不能到达满足约束条件的终结状态，则再次回溯到上一个节点。如果所有节点的所有选项都已经尝试过仍然不能到达满足约束条件的终结状态，则**该问题无解**。
- **通常回溯法算法适合用递归实现代码**。当我们到达某一个节点时，尝试所有可能的选项并在满足条件的前提下递归地抵达下一个节点。





# 回溯法的效率

- 回溯法的性能如何呢，这里要和大家说清楚了，**虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法**。
- **因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。
- 那么既然回溯法并不高效为什么还要用它呢？
  - 因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。
  - 此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索。





# 回溯法解决的问题

回溯法，一般可以解决如下几种问题：

+ 组合问题：N个数里面按一定规则找出k个数的集合
+ 切割问题：一个字符串按一定规则有几种切割方式
+ 子集问题：一个N个数的集合里有多少符合条件的子集
+ 排列问题：N个数按一定规则全排列，有几种排列方式
+ 棋盘问题：N皇后，解数独等等。





# 如何理解回溯法

- **回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！
- 因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。
- 递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。



# 回溯算法框架

思想：

废话不多说，直接上回溯算法框架，解决一个回溯问题，实际上就是一个决策树的遍历过程，站在回溯树的一个节点上，你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。



代码方面，回溯算法的框架：

```sh
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

- **其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**



# 回溯法模板

回溯三部曲：

+ **回溯函数模板返回值以及参数**

  + 回溯算法中函数返回值一般为void。

  + 再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。

  + 伪代码：

    + ```sh
      void backtracking(参数)
      ```

+ **回溯函数终止条件**

  + 既然是树形结构，那么我们在讲解[二叉树的递归 (opens new window)](https://programmercarl.com/二叉树的递归遍历.html)的时候，就知道遍历树形结构一定要有终止条件。所以回溯也有要终止条件。

  + 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

  + 所以回溯函数终止条件伪代码如下：

    ```sh
    if (终止条件) {
        存放结果;
        return;
    }
    ```

+ **回溯搜索的遍历过程**

  + 回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

  + ![image-20230508223102700](https://2021-joker.oss-cn-shanghai.aliyuncs.com/java_img/image-20230508223102700.png)

  + 注意图中，我特意举例集合大小和孩子的数量是相等的！

  + 回溯函数遍历过程伪代码如下：

    ```sh
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
    ```

  + for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。

  + backtracking这里自己调用自己，实现递归。

  + 大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。



分析完过程，回溯算法模板框架如下：

```sh
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



# THE END